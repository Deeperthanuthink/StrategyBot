"""
METF (Market EMA Trend Following) Strategy for 0DTE Credit Spreads.

This strategy follows specific rules for trading credit spreads based on
EMA crossover signals at predetermined times during the trading day.

Supported Symbols:
- SPX/SPXW: S&P 500 Index options (spread width: 25-35 points)
- SPY: S&P 500 ETF options (spread width: 2-4 points)
- QQQ: Nasdaq-100 ETF options (spread width: 3-5 points)

Rules:
1. Entry Times: 12:30, 1:00, 1:30, 2:00, 2:30, and 2:45 EST
2. Direction: 
   - 20 EMA > 40 EMA (1-min chart) → Put Credit Spread (bullish)
   - 20 EMA < 40 EMA (1-min chart) → Call Credit Spread (bearish)
3. Spread Width: Symbol-dependent (see SYMBOL_CONFIG)
4. Target Credit: Symbol-dependent
5. Stop Loss: 1x credit received
6. Hold: Till expiration
7. Avoid: FOMC days and FOMC Minutes days
"""

from dataclasses import dataclass
from datetime import datetime, date, time, timedelta
from typing import List, Optional, Tuple, Dict
from enum import Enum
import pytz

from src.logging.bot_logger import BotLogger


class TrendDirection(Enum):
    """EMA trend direction."""
    BULLISH = "bullish"  # 20 EMA > 40 EMA → Put Credit Spread
    BEARISH = "bearish"  # 20 EMA < 40 EMA → Call Credit Spread
    NEUTRAL = "neutral"  # EMAs are equal or too close


class SpreadType(Enum):
    """Type of credit spread."""
    PUT_CREDIT_SPREAD = "put_credit_spread"
    CALL_CREDIT_SPREAD = "call_credit_spread"


@dataclass
class SymbolConfig:
    """Configuration for a specific symbol."""
    spread_widths: List[int]  # Valid spread widths for this symbol
    default_spread_width: int  # Default spread width
    min_credit: float  # Minimum target credit
    max_credit: float  # Maximum target credit
    otm_offset: float  # How far OTM to place short strike (points)
    description: str  # Human-readable description


# Symbol-specific configurations
SYMBOL_CONFIGS: Dict[str, SymbolConfig] = {
    # SPX/SPXW - S&P 500 Index (~6000 price level)
    "SPX": SymbolConfig(
        spread_widths=[25, 30, 35],
        default_spread_width=30,
        min_credit=1.25,
        max_credit=2.50,
        otm_offset=15,
        description="S&P 500 Index"
    ),
    "SPXW": SymbolConfig(
        spread_widths=[25, 30, 35],
        default_spread_width=30,
        min_credit=1.25,
        max_credit=2.50,
        otm_offset=15,
        description="S&P 500 Weekly Index"
    ),
    # SPY - S&P 500 ETF (~600 price level, 1/10th of SPX)
    "SPY": SymbolConfig(
        spread_widths=[2, 3, 4, 5],
        default_spread_width=3,
        min_credit=0.15,
        max_credit=0.35,
        otm_offset=2,
        description="S&P 500 ETF"
    ),
    # QQQ - Nasdaq-100 ETF (~520 price level)
    "QQQ": SymbolConfig(
        spread_widths=[3, 4, 5, 6],
        default_spread_width=4,
        min_credit=0.15,
        max_credit=0.40,
        otm_offset=3,
        description="Nasdaq-100 ETF"
    ),
}


@dataclass
class METFSignal:
    """Signal generated by METF strategy."""
    timestamp: datetime
    trend_direction: TrendDirection
    spread_type: SpreadType
    ema_20: float
    ema_40: float
    underlying_price: float  # Renamed from spx_price for generality
    is_valid_entry_time: bool
    is_fomc_day: bool
    symbol: str  # Added symbol field


@dataclass
class METFSpreadOrder:
    """Order specification for METF credit spread."""
    symbol: str  # SPX, SPXW, SPY, or QQQ
    spread_type: SpreadType
    short_strike: float
    long_strike: float
    spread_width: float  # Actual width (may differ from target)
    expiration: date
    quantity: int
    target_credit: float
    stop_loss_credit: float  # 1x credit = close if spread doubles


@dataclass
class METFTradeResult:
    """Result of METF trade execution."""
    signal: METFSignal
    order: Optional[METFSpreadOrder]
    success: bool
    order_id: Optional[str]
    actual_credit: Optional[float]
    error_message: Optional[str]


class METFStrategy:
    """
    METF (Market EMA Trend Following) Strategy Calculator.
    
    Implements the systematic 0DTE credit spread strategy based on
    EMA crossover signals at specific times during the trading day.
    
    Supports: SPX, SPXW, SPY, QQQ
    """
    
    # Entry times in EST (Eastern Standard Time)
    ENTRY_TIMES = [
        time(12, 30),  # 12:30 PM EST
        time(13, 0),   # 1:00 PM EST
        time(13, 30),  # 1:30 PM EST
        time(14, 0),   # 2:00 PM EST
        time(14, 30),  # 2:30 PM EST
        time(14, 45),  # 2:45 PM EST
    ]
    
    # EMA periods
    EMA_FAST = 20
    EMA_SLOW = 40
    
    # Supported symbols
    SUPPORTED_SYMBOLS = list(SYMBOL_CONFIGS.keys())
    
    # Known FOMC dates for 2024-2025 (update as needed)
    FOMC_DATES_2024_2025 = [
        # 2024 FOMC Meeting Dates
        date(2024, 1, 31),
        date(2024, 3, 20),
        date(2024, 5, 1),
        date(2024, 6, 12),
        date(2024, 7, 31),
        date(2024, 9, 18),
        date(2024, 11, 7),
        date(2024, 12, 18),
        # 2025 FOMC Meeting Dates
        date(2025, 1, 29),
        date(2025, 3, 19),
        date(2025, 5, 7),
        date(2025, 6, 18),
        date(2025, 7, 30),
        date(2025, 9, 17),
        date(2025, 11, 5),
        date(2025, 12, 17),
    ]
    
    # FOMC Minutes release dates (typically 3 weeks after meeting)
    FOMC_MINUTES_DATES_2024_2025 = [
        # 2024 Minutes Dates
        date(2024, 2, 21),
        date(2024, 4, 10),
        date(2024, 5, 22),
        date(2024, 7, 3),
        date(2024, 8, 21),
        date(2024, 10, 9),
        date(2024, 11, 26),
        # 2025 Minutes Dates (approximate)
        date(2025, 1, 8),
        date(2025, 2, 19),
        date(2025, 4, 9),
        date(2025, 5, 28),
        date(2025, 7, 9),
        date(2025, 8, 20),
        date(2025, 10, 8),
        date(2025, 11, 26),
    ]
    
    def __init__(
        self,
        symbol: str = "SPX",
        default_spread_width: int = None,
        default_quantity: int = 1,
        logger: Optional[BotLogger] = None
    ):
        """
        Initialize METF Strategy.
        
        Args:
            symbol: Trading symbol (SPX, SPXW, SPY, or QQQ)
            default_spread_width: Default spread width (symbol-specific if None)
            default_quantity: Default number of contracts
            logger: Optional logger instance
        """
        symbol = symbol.upper()
        
        if symbol not in self.SUPPORTED_SYMBOLS:
            raise ValueError(
                f"Unsupported symbol: {symbol}. "
                f"Supported symbols: {', '.join(self.SUPPORTED_SYMBOLS)}"
            )
        
        self.symbol = symbol
        self.config = SYMBOL_CONFIGS[symbol]
        self.default_spread_width = default_spread_width or self.config.default_spread_width
        self.default_quantity = default_quantity
        self.logger = logger
        self.est_tz = pytz.timezone('US/Eastern')
        
        if self.default_spread_width not in self.config.spread_widths:
            raise ValueError(
                f"Spread width {self.default_spread_width} not valid for {symbol}. "
                f"Valid widths: {self.config.spread_widths}"
            )
        
        if self.logger:
            self.logger.log_info(
                f"METF Strategy initialized for {symbol}",
                {
                    "symbol": symbol,
                    "description": self.config.description,
                    "spread_widths": self.config.spread_widths,
                    "default_spread_width": self.default_spread_width,
                    "min_credit": self.config.min_credit,
                    "max_credit": self.config.max_credit,
                    "otm_offset": self.config.otm_offset
                }
            )
    
    def get_symbol_config(self) -> SymbolConfig:
        """Get the configuration for the current symbol."""
        return self.config
    
    @classmethod
    def get_supported_symbols(cls) -> List[str]:
        """Get list of supported symbols."""
        return cls.SUPPORTED_SYMBOLS
    
    @classmethod
    def get_symbol_info(cls, symbol: str) -> Optional[SymbolConfig]:
        """Get configuration info for a symbol."""
        return SYMBOL_CONFIGS.get(symbol.upper())
    
    def is_fomc_day(self, check_date: date) -> bool:
        """Check if the given date is an FOMC meeting or minutes day.
        
        Args:
            check_date: Date to check
            
        Returns:
            True if FOMC day, False otherwise
        """
        is_meeting = check_date in self.FOMC_DATES_2024_2025
        is_minutes = check_date in self.FOMC_MINUTES_DATES_2024_2025
        
        if self.logger and (is_meeting or is_minutes):
            event_type = "FOMC Meeting" if is_meeting else "FOMC Minutes"
            self.logger.log_warning(
                f"METF: {event_type} day detected - trading not recommended",
                {"date": check_date.isoformat(), "event": event_type}
            )
        
        return is_meeting or is_minutes
    
    def is_valid_entry_time(self, check_time: datetime) -> bool:
        """Check if current time is a valid entry time.
        
        Args:
            check_time: Datetime to check (will be converted to EST)
            
        Returns:
            True if valid entry time, False otherwise
        """
        # Convert to EST
        if check_time.tzinfo is None:
            check_time = pytz.utc.localize(check_time)
        est_time = check_time.astimezone(self.est_tz).time()
        
        # Check if within 2 minutes of any entry time
        for entry_time in self.ENTRY_TIMES:
            entry_dt = datetime.combine(date.today(), entry_time)
            check_dt = datetime.combine(date.today(), est_time)
            diff = abs((entry_dt - check_dt).total_seconds())
            
            if diff <= 120:  # Within 2 minutes
                return True
        
        return False
    
    def get_next_entry_time(self, current_time: datetime) -> Optional[datetime]:
        """Get the next valid entry time.
        
        Args:
            current_time: Current datetime
            
        Returns:
            Next entry time or None if no more entries today
        """
        if current_time.tzinfo is None:
            current_time = pytz.utc.localize(current_time)
        est_now = current_time.astimezone(self.est_tz)
        current_time_only = est_now.time()
        
        for entry_time in self.ENTRY_TIMES:
            if entry_time > current_time_only:
                return self.est_tz.localize(
                    datetime.combine(est_now.date(), entry_time)
                )
        
        return None
    
    def calculate_ema(self, prices: List[float], period: int) -> float:
        """Calculate Exponential Moving Average.
        
        Args:
            prices: List of prices (most recent last)
            period: EMA period
            
        Returns:
            EMA value
        """
        if len(prices) < period:
            raise ValueError(f"Need at least {period} prices for EMA calculation")
        
        multiplier = 2 / (period + 1)
        
        # Start with SMA for first EMA value
        ema = sum(prices[:period]) / period
        
        # Calculate EMA for remaining prices
        for price in prices[period:]:
            ema = (price - ema) * multiplier + ema
        
        return ema
    
    def determine_trend(
        self,
        prices_1min: List[float],
        min_ema_diff_percent: float = 0.01
    ) -> Tuple[TrendDirection, float, float]:
        """Determine trend direction based on EMA crossover.
        
        Args:
            prices_1min: List of 1-minute closing prices (need at least 40)
            min_ema_diff_percent: Minimum EMA difference to confirm trend (default 0.01%)
            
        Returns:
            Tuple of (TrendDirection, ema_20, ema_40)
        """
        if len(prices_1min) < self.EMA_SLOW:
            raise ValueError(f"Need at least {self.EMA_SLOW} 1-minute prices")
        
        ema_20 = self.calculate_ema(prices_1min, self.EMA_FAST)
        ema_40 = self.calculate_ema(prices_1min, self.EMA_SLOW)
        
        # Calculate percentage difference
        ema_diff_percent = abs(ema_20 - ema_40) / ema_40 * 100
        
        if self.logger:
            self.logger.log_info(
                f"METF EMA Analysis",
                {
                    "ema_20": f"{ema_20:.2f}",
                    "ema_40": f"{ema_40:.2f}",
                    "diff_percent": f"{ema_diff_percent:.4f}%",
                    "min_diff_required": f"{min_ema_diff_percent}%"
                }
            )
        
        # Determine trend
        if ema_diff_percent < min_ema_diff_percent:
            return TrendDirection.NEUTRAL, ema_20, ema_40
        elif ema_20 > ema_40:
            return TrendDirection.BULLISH, ema_20, ema_40
        else:
            return TrendDirection.BEARISH, ema_20, ema_40
    
    def get_spread_type(self, trend: TrendDirection) -> Optional[SpreadType]:
        """Get the appropriate spread type based on trend.
        
        Args:
            trend: Current trend direction
            
        Returns:
            SpreadType or None if neutral
        """
        if trend == TrendDirection.BULLISH:
            # Bullish = 20 EMA > 40 EMA → Sell Put Credit Spread
            return SpreadType.PUT_CREDIT_SPREAD
        elif trend == TrendDirection.BEARISH:
            # Bearish = 20 EMA < 40 EMA → Sell Call Credit Spread
            return SpreadType.CALL_CREDIT_SPREAD
        else:
            return None
    
    def calculate_strikes(
        self,
        current_price: float,
        spread_type: SpreadType,
        spread_width: float = None,
        available_strikes: List[float] = None,
        target_credit_min: float = None,
        target_credit_max: float = None
    ) -> Tuple[float, float]:
        """Calculate optimal strike prices for the credit spread.
        
        IMPORTANT: This method ONLY uses strikes from the available_strikes list.
        It never calculates theoretical strikes - all returned strikes are real
        tradeable strikes from the option chain.
        
        Args:
            current_price: Current underlying price
            spread_type: PUT_CREDIT_SPREAD or CALL_CREDIT_SPREAD
            spread_width: Target width of spread (uses symbol default if None)
            available_strikes: List of REAL available strike prices from API
            target_credit_min: Minimum target credit (uses symbol default if None)
            target_credit_max: Maximum target credit (uses symbol default if None)
            
        Returns:
            Tuple of (short_strike, long_strike) - both are REAL strikes
            
        Raises:
            ValueError: If no suitable strikes available
        """
        # Use symbol-specific defaults
        spread_width = spread_width or self.default_spread_width
        target_credit_min = target_credit_min or self.config.min_credit
        target_credit_max = target_credit_max or self.config.max_credit
        otm_offset = self.config.otm_offset
        
        if not available_strikes:
            raise ValueError("No available strikes provided - cannot calculate spread")
        
        # Sort strikes
        strikes = sorted(available_strikes)
        
        if spread_type == SpreadType.PUT_CREDIT_SPREAD:
            # Put Credit Spread: Sell higher strike put, buy lower strike put
            # Want short strike below current price (OTM)
            
            # Find strikes below current price (OTM puts)
            otm_strikes = [s for s in strikes if s < current_price]
            
            if not otm_strikes:
                raise ValueError(f"No OTM put strikes available below current price ${current_price:.2f}")
            
            # Target short strike using symbol-specific OTM offset
            target_short = current_price - otm_offset
            
            # Find closest REAL strike to target
            short_strike = min(otm_strikes, key=lambda x: abs(x - target_short))
            
            # Find long strike that gives us approximately the desired spread width
            # Must be a REAL strike from the available list
            target_long = short_strike - spread_width
            available_longs = [s for s in strikes if s < short_strike]
            
            if not available_longs:
                raise ValueError(f"No strikes available below short strike ${short_strike:.2f}")
            
            # Find the REAL strike closest to our target spread width
            long_strike = min(available_longs, key=lambda x: abs(x - target_long))
                    
        else:  # CALL_CREDIT_SPREAD
            # Call Credit Spread: Sell lower strike call, buy higher strike call
            # Want short strike above current price (OTM)
            
            # Find strikes above current price (OTM calls)
            otm_strikes = [s for s in strikes if s > current_price]
            
            if not otm_strikes:
                raise ValueError(f"No OTM call strikes available above current price ${current_price:.2f}")
            
            # Target short strike using symbol-specific OTM offset
            target_short = current_price + otm_offset
            
            # Find closest REAL strike to target
            short_strike = min(otm_strikes, key=lambda x: abs(x - target_short))
            
            # Find long strike that gives us approximately the desired spread width
            # Must be a REAL strike from the available list
            target_long = short_strike + spread_width
            available_longs = [s for s in strikes if s > short_strike]
            
            if not available_longs:
                raise ValueError(f"No strikes available above short strike ${short_strike:.2f}")
            
            # Find the REAL strike closest to our target spread width
            long_strike = min(available_longs, key=lambda x: abs(x - target_long))
        
        # Calculate actual spread width (may differ from target due to available strikes)
        actual_width = abs(long_strike - short_strike)
        
        if self.logger:
            self.logger.log_info(
                f"METF Strike Selection for {self.symbol} (REAL STRIKES ONLY)",
                {
                    "symbol": self.symbol,
                    "spread_type": spread_type.value,
                    "current_price": f"{current_price:.2f}",
                    "short_strike": f"{short_strike:.2f}",
                    "long_strike": f"{long_strike:.2f}",
                    "target_width": spread_width,
                    "actual_width": actual_width,
                    "otm_offset": otm_offset,
                    "strikes_are_real": True
                }
            )
        
        return short_strike, long_strike
    
    def generate_signal(
        self,
        current_time: datetime,
        underlying_price: float,
        prices_1min: List[float]
    ) -> METFSignal:
        """Generate METF trading signal.
        
        Args:
            current_time: Current datetime
            underlying_price: Current price of the underlying (SPX, SPY, or QQQ)
            prices_1min: List of 1-minute closing prices
            
        Returns:
            METFSignal with trade recommendation
        """
        # Check FOMC day
        check_date = current_time.date() if hasattr(current_time, 'date') else date.today()
        is_fomc = self.is_fomc_day(check_date)
        
        # Check entry time
        is_valid_time = self.is_valid_entry_time(current_time)
        
        # Determine trend
        trend, ema_20, ema_40 = self.determine_trend(prices_1min)
        
        # Get spread type
        spread_type = self.get_spread_type(trend)
        
        signal = METFSignal(
            timestamp=current_time,
            trend_direction=trend,
            spread_type=spread_type if spread_type else SpreadType.PUT_CREDIT_SPREAD,
            ema_20=ema_20,
            ema_40=ema_40,
            underlying_price=underlying_price,
            is_valid_entry_time=is_valid_time,
            is_fomc_day=is_fomc,
            symbol=self.symbol
        )
        
        if self.logger:
            self.logger.log_info(
                f"METF Signal Generated for {self.symbol}",
                {
                    "symbol": self.symbol,
                    "timestamp": current_time.isoformat(),
                    "trend": trend.value,
                    "spread_type": spread_type.value if spread_type else "none",
                    "ema_20": f"{ema_20:.2f}",
                    "ema_40": f"{ema_40:.2f}",
                    "underlying_price": f"{underlying_price:.2f}",
                    "is_valid_time": is_valid_time,
                    "is_fomc_day": is_fomc,
                    "should_trade": is_valid_time and not is_fomc and spread_type is not None
                }
            )
        
        return signal
    
    def create_order(
        self,
        signal: METFSignal,
        available_strikes: List[float],
        spread_width: float = None,
        quantity: int = None
    ) -> Optional[METFSpreadOrder]:
        """Create order based on signal.
        
        Args:
            signal: METF signal
            available_strikes: List of available strike prices
            spread_width: Spread width (default from symbol config)
            quantity: Number of contracts (default from config)
            
        Returns:
            METFSpreadOrder or None if signal is not tradeable
        """
        # Check if we should trade
        if signal.is_fomc_day:
            if self.logger:
                self.logger.log_warning("METF: Skipping trade - FOMC day")
            return None
        
        if not signal.is_valid_entry_time:
            if self.logger:
                self.logger.log_warning("METF: Skipping trade - not a valid entry time")
            return None
        
        if signal.trend_direction == TrendDirection.NEUTRAL:
            if self.logger:
                self.logger.log_warning("METF: Skipping trade - neutral trend")
            return None
        
        spread_width = spread_width or self.default_spread_width
        quantity = quantity or self.default_quantity
        
        # Calculate strikes
        short_strike, long_strike = self.calculate_strikes(
            signal.underlying_price,
            signal.spread_type,
            spread_width,
            available_strikes
        )
        
        # Target credit (middle of symbol-specific range)
        target_credit = (self.config.min_credit + self.config.max_credit) / 2
        
        # Stop loss at 1x credit (spread value doubles)
        stop_loss_credit = target_credit * 2
        
        order = METFSpreadOrder(
            symbol=self.symbol,
            spread_type=signal.spread_type,
            short_strike=short_strike,
            long_strike=long_strike,
            spread_width=abs(long_strike - short_strike),
            expiration=signal.timestamp.date(),  # 0DTE
            quantity=quantity,
            target_credit=target_credit,
            stop_loss_credit=stop_loss_credit
        )
        
        if self.logger:
            self.logger.log_info(
                f"METF Order Created for {self.symbol}",
                {
                    "symbol": order.symbol,
                    "spread_type": order.spread_type.value,
                    "short_strike": f"${order.short_strike:.2f}",
                    "long_strike": f"${order.long_strike:.2f}",
                    "spread_width": order.spread_width,
                    "expiration": order.expiration.isoformat(),
                    "quantity": order.quantity,
                    "target_credit": f"${order.target_credit:.2f}",
                    "stop_loss": f"${order.stop_loss_credit:.2f}"
                }
            )
        
        return order
    
    def get_entry_times_display(self) -> str:
        """Get formatted string of entry times for display."""
        times = [t.strftime("%I:%M %p") for t in self.ENTRY_TIMES]
        return ", ".join(times) + " EST"
    
    def get_symbol_info_display(self) -> str:
        """Get formatted string of symbol configuration for display."""
        return (
            f"{self.symbol} ({self.config.description})\n"
            f"  Spread widths: {self.config.spread_widths}\n"
            f"  Target credit: ${self.config.min_credit:.2f} - ${self.config.max_credit:.2f}\n"
            f"  OTM offset: {self.config.otm_offset} points"
        )


def create_metf_strategy(
    symbol: str = "SPX",
    spread_width: float = None,
    quantity: int = 1,
    logger: Optional[BotLogger] = None
) -> METFStrategy:
    """Factory function to create METF strategy.
    
    Args:
        symbol: Trading symbol (SPX, SPXW, SPY, or QQQ)
        spread_width: Default spread width (uses symbol default if None)
        quantity: Default number of contracts
        logger: Optional logger instance
        
    Returns:
        Configured METFStrategy instance
    """
    return METFStrategy(
        symbol=symbol,
        default_spread_width=spread_width,
        default_quantity=quantity,
        logger=logger
    )
